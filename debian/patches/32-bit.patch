Description: Fixes for 32-bit builds.
 - Use "%zu" for format when printing size_t.
 - Use mp_limb_t instead of uint64_t for arrays of primes that are passed
   to flint CRT functions.
Author: Doug Torrance <dtorrance@debian.org>
Forwarded: https://github.com/algebraic-solving/msolve/pull/164
Last-Update: 2024-07-25

--- a/src/msolve/lifting-gb.c
+++ b/src/msolve/lifting-gb.c
@@ -47,9 +47,9 @@
 typedef struct {
   uint32_t alloc; /* alloc -> max number of primes */
   uint32_t nprimes; /* number of primes */
-  uint64_t *primes; /* array of prime numbers encoded with uint64_t to ensure
+  mp_limb_t *primes; /* array of prime numbers encoded with uint64_t to ensure
                        compatibility with flint */
-  uint64_t *cf_64; /* array of length equal to number of primes which will be used
+  mp_limb_t *cf_64; /* array of length equal to number of primes which will be used
                     to copy coefficients (hence ensuring compatibility with
                     flint) */
   uint32_t ld; /* number of polynomials */
@@ -167,8 +167,8 @@
                                    int32_t *lm, int32_t *basis){
   modgbs->alloc = alloc;
   modgbs->nprimes = 0;
-  modgbs->primes = (uint64_t *)calloc(alloc, sizeof(uint64_t));
-  modgbs->cf_64 = (uint64_t *)calloc(alloc, sizeof(uint64_t));
+  modgbs->primes = (mp_limb_t *)calloc(alloc, sizeof(mp_limb_t));
+  modgbs->cf_64 = (mp_limb_t *)calloc(alloc, sizeof(mp_limb_t));
   modgbs->ld = ld;
   modgbs->nv = nv;
   modgbs->modpolys = (modpolys_t *)malloc(sizeof(modpolys_t) * ld);
@@ -205,8 +205,8 @@
   uint32_t oldalloc = modgbs->alloc;
   modgbs->alloc += newalloc;
 
-  uint64_t *newprimes = (uint64_t *)realloc(modgbs->primes,
-                                            modgbs->alloc * sizeof(uint64_t));
+  mp_limb_t *newprimes = (mp_limb_t *)realloc(modgbs->primes,
+                                            modgbs->alloc * sizeof(mp_limb_t));
 
   if(newprimes == NULL){
     fprintf(stderr, "Problem when reallocating modgbs (primes)\n");
@@ -217,8 +217,8 @@
     modgbs->primes[i] = 0;
   }
 
-  uint64_t *ncf_64 = (uint64_t *)realloc(modgbs->cf_64,
-                                         modgbs->alloc * sizeof(uint64_t));
+  mp_limb_t *ncf_64 = (mp_limb_t *)realloc(modgbs->cf_64,
+                                         modgbs->alloc * sizeof(mp_limb_t));
   if(ncf_64 == NULL){
     fprintf(stderr, "Problem when reallocating modgbs (cfs)\n");
     exit(1);
@@ -840,7 +840,7 @@
                                               int32_t *coef, mpz_t mod_p, mpz_t prod_p,
                                               int thrds){
 
-  uint64_t newprime = modgbs->primes[modgbs->nprimes - 1 ];
+  mp_limb_t newprime = modgbs->primes[modgbs->nprimes - 1 ];
   /* all primes are assumed to be good primes */
   mpz_mul_ui(prod_p, mod_p, (uint32_t)newprime);
   for(int32_t k = 0; k < dl->end; k++){
@@ -986,7 +986,7 @@
   for(int32_t k = 0; k < modgbs->ld; k++){
     if(dl->check1[k]>=1 && dl->check2[k] > 0 && dl->check2[k] < NBCHECK){
       for(int i = 0; i < thrds; i++){
-        uint32_t prime = modgbs->primes[modgbs->nprimes - (thrds - i) ];
+        mp_limb_t prime = modgbs->primes[modgbs->nprimes - (thrds - i) ];
         for(int32_t c = 0; c < modgbs->modpolys[k]->len; c++){
           mpz_mul(den, modgbs->modpolys[k]->lm, modgbs->modpolys[k]->cf_qq[2*c+1]);
           uint32_t coef = modgbs->modpolys[k]->cf_32[c][modgbs->nprimes   - (thrds - i) ];
@@ -1016,7 +1016,7 @@
     }
     for(int i = 0; i < thrds; i++){
 
-      uint32_t prime = modgbs->primes[modgbs->nprimes - (thrds - i) ];
+      mp_limb_t prime = modgbs->primes[modgbs->nprimes - (thrds - i) ];
       uint32_t coef = modgbs->modpolys[k]->cf_32[dl->coef[k]][modgbs->nprimes  - (thrds - i) ];
       int boo = verif_coef(dl->num[k], dl->den[k], prime, coef);
 
--- a/src/msolve/lifting.c
+++ b/src/msolve/lifting.c
@@ -204,7 +204,7 @@
         int32_t *tmp = (int32_t *)realloc(trace_det->modular_matrices, 
                 sz2 * sizeof(int32_t));
         if(tmp == NULL){
-            fprintf(stderr, "Problem when allocating modular matrices (amount = %ld)\n", trace_det->mat_alloc * sz);
+            fprintf(stderr, "Problem when allocating modular matrices (amount = %zu)\n", trace_det->mat_alloc * sz);
             exit(1);
         }
         for(int64_t i = sz*old_alloc; i < sz2; i++){
